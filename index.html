<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Fluxi 2.0 – Semantic Flowchart</title>
  <style>
    body { margin:0; padding:0; font-family:sans-serif; }
    #toolbar { padding:1rem; background:#f0f0f0; display:flex; gap:0.5rem; align-items:center; border-bottom:1px solid #ccc; }
    #toolbar input[type=text] { flex:1; padding:0.5rem; border:1px solid #999; border-radius:4px; }
    #toolbar button { padding:0.5rem 1rem; border:none; border-radius:4px; background:#007bff; color:#fff; cursor:pointer; }
    #toolbar button:hover { background:#0056b3; }
    #canvas {
      position:relative; width:100vw; height:calc(100vh - 60px);
      background:
        linear-gradient(to right, rgba(0,0,0,0.05) 1px, transparent 1px),
        linear-gradient(to bottom, rgba(0,0,0,0.05) 1px, transparent 1px);
      background-size:20px 20px; overflow:auto;
    }
    svg { position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; z-index:5; }
    svg defs marker path { fill:#333; }

    .node {
      position:absolute; border-radius:6px; box-shadow:0 2px 5px rgba(0,0,0,0.2);
      color:#fff; cursor:move; user-select:none; min-width:120px; padding:0.75rem; z-index:10;
      background:#343a40;
    }
    .node.step  { background:#343a40; }
    .node.goal  { background:#28a745; }
    .node.tool  { background:#17a2b8; min-width:180px; }
    /* rombo per gate */
    .node.gate {
      width:80px; height:80px; padding:0; background:#6f42c1;
      border-radius:0;
    }
    .node.gate .inner {
      transform:rotate(-45deg); width:80px; height:80px;
      display:flex; flex-direction:column; align-items:center; justify-content:center;
    }

    .node .title { font-weight:bold; margin-bottom:0.5rem; cursor:text; text-align:center; }
    .node input {
      width:calc(100% - 10px); margin-bottom:0.25rem;
      padding:4px; border:1px solid #ccc; border-radius:3px;
      cursor:text; color:#000; user-select:text;
    }
    .details { display:none; }
  </style>
</head>
<body>
  <div id="toolbar">
    <input type="text" id="goalText" placeholder="Enter goal (last node)" />
    <button onclick="addStep()">Add Step</button>
    <button onclick="addGate()">Add Gate</button>
    <button onclick="addGoal()">Add Goal</button>
    <button onclick="addTool()">Add Tool</button>
    <button id="connectBtn" onclick="toggleConnect()">Connect Nodes</button>
    <button onclick="exportJSON()">Export JSON</button>
    <button onclick="importBtn.click()">Import JSON</button>
    <input type="file" id="importBtn" accept="application/json" style="display:none" onchange="importJSON(event)">
  </div>
  <div id="canvas">
    <svg id="connections">
      <defs>
        <marker id="arrow" markerWidth="8" markerHeight="8" refX="7" refY="4" orient="auto">
          <path d="M0,0 L8,4 L0,8 Z"/>
        </marker>
      </defs>
    </svg>
  </div>
  <script>
    let idCounter=0, connections=[], connectMode=false, firstNode=null;
    const canvas=document.getElementById('canvas'),
          svg=document.getElementById('connections'),
          importBtn=document.getElementById('importBtn');

    function addStep(){ createNode('step'); }
    function addGate(){ createNode('gate'); }
    function addGoal(){ createNode('goal', document.getElementById('goalText').value || 'Goal'); }
    function addTool(){ createNode('tool', 'Tool'); }

    function createNode(type,text,forcedId){
      const id=forcedId||('n'+(idCounter++));
      const div=document.createElement('div');
      div.className='node '+type;
      div.dataset.id=id; div.dataset.type=type;
      div.style.left='50px'; div.style.top='50px';

      if(type==='gate'){
        const inner=document.createElement('div'); inner.className='inner';
        const title=document.createElement('div'); title.className='title'; title.contentEditable=true;
        title.innerText=text||'Gate'; inner.appendChild(title);
        ['cond','then','else'].forEach(f=>{
          const inp=document.createElement('input'); inp.placeholder=f; inp.className=f;
          inner.appendChild(inp);
        });
        div.appendChild(inner);

      } else {
        const title=document.createElement('div'); title.className='title'; title.contentEditable=true;
        title.innerText=text||(type==='step'?'Step '+id:type==='tool'?'Tool':'Goal');
        div.appendChild(title);

        const details=document.createElement('div'); details.className='details';
        if(type==='step') ['action','output'].forEach(f=>{
          const inp=document.createElement('input'); inp.placeholder=f; inp.className=f; details.appendChild(inp);
        });
        if(type==='tool') ['name','description','input_schema','output_schema'].forEach(f=>{
          const inp=document.createElement('input'); inp.placeholder=f; inp.className=f; details.appendChild(inp);
        });
        div.appendChild(details);
        div.addEventListener('dblclick',e=>{
          e.stopPropagation();
          details.style.display = details.style.display==='block'?'none':'block';
        });
      }

      makeDraggable(div);
      div.addEventListener('click',e=>{
        if(connectMode && !e.target.isContentEditable){
          e.stopPropagation();
          if(!firstNode) firstNode=div;
          else {
            connections.push([firstNode.dataset.id,div.dataset.id]);
            firstNode=null;
            toggleConnect(true);
            drawConnections();
          }
        }
      });

      canvas.appendChild(div);
      drawConnections();
    }

    function makeDraggable(el){
      el.addEventListener('mousedown',e=>{
        if(e.target.tagName==='INPUT'||e.target.isContentEditable) return;
        let dx=e.offsetX, dy=e.offsetY, dragging=true;
        function mm(ev){
          if(!dragging) return;
          let x=ev.pageX-canvas.getBoundingClientRect().left-dx;
          let y=ev.pageY-canvas.getBoundingClientRect().top-dy;
          el.style.left=Math.round(x/20)*20+'px';
          el.style.top =Math.round(y/20)*20+'px';
          drawConnections();
        }
        function mu(){ dragging=false; document.removeEventListener('mousemove',mm); document.removeEventListener('mouseup',mu); }
        document.addEventListener('mousemove',mm);
        document.addEventListener('mouseup',mu);
      });
    }

    function toggleConnect(forceOff){
      connectMode = forceOff?false:!connectMode;
      document.getElementById('connectBtn').style.background = connectMode?'#ffc':'#007bff';
      if(!connectMode) firstNode=null;
    }

    function drawConnections(){
      svg.querySelectorAll('line').forEach(l=>l.remove());
      const nodes=[...document.querySelectorAll('.node')];
      connections.forEach(([f,t])=>{
        const from=nodes.find(n=>n.dataset.id===f),
              to  =nodes.find(n=>n.dataset.id===t);
        if(!from||!to) return;
        const a=from.getBoundingClientRect(), b=to.getBoundingClientRect(), c=canvas.getBoundingClientRect();
        const x1=a.left+a.width/2-c.left, y1=a.top+a.height/2-c.top,
              x2=b.left+b.width/2-c.left, y2=b.top+b.height/2-c.top;
        const line=document.createElementNS('http://www.w3.org/2000/svg','line');
        line.setAttribute('x1',x1); line.setAttribute('y1',y1);
        line.setAttribute('x2',x2); line.setAttribute('y2',y2);
        line.setAttribute('stroke','#333'); line.setAttribute('stroke-width','2');
        line.setAttribute('marker-end','url(#arrow)');
        svg.appendChild(line);
      });
    }

    function exportJSON(){
      const goal=document.getElementById('goalText').value;
      const all=[...document.querySelectorAll('.node')];
      const tools=all.filter(d=>d.dataset.type==='tool').map(div=>({
        name:div.querySelector('.name').value||div.querySelector('.title').innerText,
        description:div.querySelector('.description').value,
        input_schema:div.querySelector('.input_schema').value,
        output_schema:div.querySelector('.output_schema').value
      }));
      const steps=all.filter(d=>d.dataset.type!=='tool').map(div=>{
        const id=div.dataset.id, type=div.dataset.type;
        if(type==='step') return {id,action:div.querySelector('.action').value,output:div.querySelector('.output').value};
        if(type==='gate') return {
          id,type:'gate',
          condition:{if:div.querySelector('.cond').value},
          then:{set:{value:div.querySelector('.then').value}},
          else:{set:{value:div.querySelector('.else').value}}
        };
        return {id,text:div.querySelector('.title').innerText};
      });
      const data={goal,context:{},tools,steps,connections,criteria:{}};
      const blob=new Blob([JSON.stringify(data,null,2)],{type:'application/json'});
      const a=document.createElement('a'); a.href=URL.createObjectURL(blob);
      a.download='semantic_flow.json'; a.click();
    }

    function importJSON(evt){
      const file=evt.target.files[0]; if(!file) return;
      const reader=new FileReader();
      reader.onload=e=>{
        const d=JSON.parse(e.target.result);
        document.querySelectorAll('.node').forEach(n=>n.remove());
        connections=[]; document.getElementById('goalText').value=d.goal||'';
        // create tools, track map name→id
        const toolMap = {};
        (d.tools||[]).forEach((t,i)=>{
          const tid='t'+i;
          createNode('tool',t.name,tid);
          const div=document.querySelector(`[data-id='${tid}']`);
          div.querySelector('.description').value=t.description||'';
          div.querySelector('.input_schema').value=t.input_schema||'';
          div.querySelector('.output_schema').value=t.output_schema||'';
          toolMap[t.name]=tid;
        });
        // create steps/goals/gates
        (d.steps||[]).forEach(st=>{
          const type=st.type==='gate'?'gate':st.text?'goal':'step';
          createNode(type,st.text||st.id,st.id);
          const div=document.querySelector(`[data-id='${st.id}']`);
          if(type==='step'){
            div.querySelector('.action').value=st.action||'';
            div.querySelector('.output').value=st.output||'';
          }
          if(type==='gate'){
            div.querySelector('.cond').value=st.condition?.if||'';
            div.querySelector('.then').value=st.then?.set?.value||'';
            div.querySelector('.else').value=st.else?.set?.value||'';
          }
        });
        // auto-link if missing
        if(!Array.isArray(d.connections)){
          // tools → steps by action match
          d.steps.forEach(st=>{
            if(st.action && toolMap[st.action]){
              connections.push([toolMap[st.action], st.id]);
            }
          });
          // chain steps + goal
          for(let i=0; i<d.steps.length-1; i++){
            connections.push([d.steps[i].id, d.steps[i+1].id]);
          }
          // last step → goal (if any)
          if(d.steps.length && d.goal){
            connections.push([d.steps[d.steps.length-1].id, 'n'+(idCounter)]); 
          }
        } else {
          d.connections.forEach(c=>connections.push(c));
        }
        // bump counter
        const ids=d.steps.map(st=>parseInt((st.id.match(/\d+$/)||['0'])[0],10));
        idCounter=Math.max(...ids,idCounter)+1;
        drawConnections();
      };
      reader.readAsText(file);
    }
  </script>
</body>
</html>